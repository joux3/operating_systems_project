OS Project, readme round 2

Group 02
Members
    Antti Risteli
    Miro Nurmela
    Olli-Matti Saatio

--------

Assignment 1
1. Changed files
    - excepption.c (excepction handling to userland processes in order to prevent
      constant kernel panics)
    - thread.c/h (added the flags that signify that copying between kernel and
      userland is in process)
    - process.c/h (functions to do the actual copying between kernel and userland)


2. Description of the solution
    - the solution works as follows (for copying both certain length strings and blocks
      of predefined size)
        - get the current thread entry
        - decide which way we are copying (kernel -> userland or userland -> kernel)
        - assert that we are currently not copying
        - put up the flag that tells that copying in process
        - then, for each byte to be copied, check that the userland pointer is in a
          userland legal region (userland mapped memory)
            - if it is, copy the byte and process the next byte
            - if it's not, put down the copying flag and return an error
            - if an error has occured at some point, also put down the copy flag
              and return error
        - finally, if all went well, return the amount of bytes copied

3. Motivation behind the solution
    - the solution aims for simplicity and throroughness, and checking every byte seems
      like the way to do it

4. Changes to the plan presented in the review session
    - None

----------

Assignment 2

1. Changed files
    - process.c/h contains the tables and data structures for this assignment

2. Description of the solution
    - in this assignment we have implemented two data structures for the processes - 
      one table for process entries and one table for filehandles
    - both tables are protected with a lock in order to satisfy the synchronization
      requirement ofthe assignment
    - the size of the filehandle table is capped by the maximum number of open files
    - the size of the process table is capped at 64
    - the process entry stores:
        - the name of the process (executable name + where it's found on the file system)
        - process state (free, running, zombie), where free signifies that the entry is free
        - the process id of the parent
        - return value of the process
    - the filehandle entry contains:
        - flag telling if the entry is in use
        - the owner of the entry
        - the openfile_t identifier of of the file in the filesystem
    - there's also a condition variable that is used to put the processes that are waiting for
      their children to sleep, but more on that in syscall_join

3. Motivation behind the solution
    - tables with locks are the simplest synchronized data structures

4. Changes to the plan presented in the review session
    - none

Assignment 3

1. Changed files

2. Description of the solution

3. Motivation behind the solution

4. Changes to the plan presented in the review session

Assignment 4

1. Changed files

2. Description of the solution

3. Motivation behind the solution

4. Changes to the plan presented in the review session

Assignment 5

1. Changed files

2. Description of the solution

3. Motivation behind the solution

4. Changes to the plan presented in the review session
